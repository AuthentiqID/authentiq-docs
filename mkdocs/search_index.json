{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nHey, if you\nre reading this, then you are probably curious how to get started with implementing \nAuthentiq\n on your website. \n\n\nFortunately, as we run Authentiq Connect as a service, there is no need to install or run anything locally. Simply include our JavaScript snippet on your page or point your favourite OAuth 2.0 client library at our hosted instance. Dive right in by heading over to the \nGetting started\n page.\n\n\nOf course if you prefer to \ninstall the Authentiq Connect daemon locally\n, then we will have pre-built packages for Debian 7.0, 8.0 and Ubuntu 15.04 soon. You will also be able to install the Authentiq Connect Provider from PyPI or build it from \nsource\n.\n\n\n\n\nPlease see our licensing options before installing Authentiq Connect locally to make sure it matches your situation.\n\n\n\n\nWhy Authentiq?\n\n\nWhy should I do this and what\ns so cool about the Authentiq technology again?\n\n\n\n\nAuthentiq provides super secure multi-factor authentication.\n\n\nAuthentiq provides you with fresh contact details every time a user signs in.\n\n\nAuthentiq lets your end-users control their identity from their phone.\n\n\nAuthentiq aims to avoid being a single point of failure for your product.\n\n\nAuthentiq aims to avoid being another point of trust for your users.\n\n\nAuthentiq aims to be reasonably priced, or free.\n\n\n\n\nConcepts\n\n\nThis section attempts to explain general concepts relating to Authentiq Connect.\n\n\nScopes\n\n\nAuthentiq Connect leverages OAuth 2.0 \nscopes\n to specify what sections of a user\ns profile are being requested. We mimic the \nscopes from OIDC\n as much as possible, and prefix additional scopes with a \naq:\n.\n\n\nIdentity claims\n\n\nUsing scopes, a client application can request the following user details from a user.  \n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\nClaims\n\n\nCan be marked required?\n\n\nCan be signed?\n\n\n\n\n\n\n\n\n\n\nemail\n\n\nA user\ns (verified) email address.\n\n\nemail\n, \nemail_verified\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nphone\n\n\nA user\ns (verified) phone number.\n\n\nphone_number\n, \nphone_number_verified\n\n\nYes\n\n\nYes\n\n\n\n\n\n\naddress\n\n\nA user\ns home address.\n\n\naddress\n\n\nYes\n\n\nNo\n\n\n\n\n\n\naq:name\n\n\nA user\ns full name.\n\n\nname\n, \ngiven_name\n, \nfamily_name\n, \nmiddle_name\n, \nnickname\n\n\nYes\n\n\nNo\n\n\n\n\n\n\naq:location\n\n\nA user\ns current location.\n\n\naq:location\n\n\nYes\n\n\nNo\n\n\n\n\n\n\n\n\nFollowing OIDC, requested scopes are optional by default, meaning that a user will be able to opt out of a requested scope on the Authentiq ID user consent screen. In this case it is up to the client application to decide how to deal with the missing information. Alternatively, Authentiq allows a developer to mark certain scopes as required and/or requiring a signature from a trusted issuer. \n\n\nRequired claims\n\n\nIdentity scopes can be marked as being \nrequired\n by appending \n~r\n, for instance \nemail~r\n or \naq:name~r\n. Doing so will prevent a user from opting out of the section when signing in from the Authentiq ID app. We recommend to use this flag with care and instead let your users remain in control of the information they share with you.  \n\n\nSigned claims\n\n\nScopes can also be marked to \nrequire a signature\n from an externally trusted party. In fact, Authentiq is acting as a signature provider for the email and phone scopes, handling the confirmation of email addresses and phone number using a one-time verification code sent by email or text message.\n\n\nFunctional scopes\n\n\nAuthentiq Connect also uses scopes to indicate functional preferences. \n\n\n\n\n\n\n\n\nLabel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naq:push\n\n\nWhether or not to offer \nOne click sign-in\n to the user.\n\n\n\n\n\n\n\n\nErrors\n\n\nWhen something goes wrong, Authentiq Connect tries to direct back to the client application as stipulated by OAuth 2.0, so that the error can be handled in the domain and using the UX of the client application.\n\n\nThe native SDK handles all errors for you, however here is a list of things that may go wrong for reference.\n\n\n\n\n\n\n\n\nError\n\n\nOrigin\n\n\nGrants\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninvalid_XYZ\n\n\nOAuth 2.0\n\n\nAuthorization code\n\n\n\n\n\n\n\n\nconsent_required\n\n\nOIDC\n\n\nAuthorization code\n\n\nThe user did not The user did not The user did not The user did not\n\n\n\n\n\n\n\n\nTerminology\n\n\nLet\ns get over some terminology used in this documentation.\n\n\n\n\nAuthentiq Connect\n\n\nThe authentication protocol defined by Authentiq.\n\n\nAuthentiq Connect Provider\n\n\nThe actual daemon that serves the Authentiq Connect protocol, acting as a bridge between website and app. The provider is packaged as \nauthentiqd\n in the context of SysV-style init scripts.\n\n\nAuthentiq Connect SDK\n\n\nThe combination of the hosted (or installable) Authentiq Connect Provider and client side JavaScript snippet.\n\n\nClient or Relying Party\n\n\nThe client website or application that end-users authenticate to. Both Client and Relying Party are used interchangeably in the OpenID Connect specifications.\n\n\nCertificate Authority List\n\n\nA public list of signature authorities that allows a Relying Party to verify that a certain identity claim was signed by an active trusted party.\n\n\nCertificate Revocation List\n\n\nA public list of unique end-user and (hashed) device identifiers that can be used by a Relying Party to verify that a user is still active and their device hasn\nt been revoked. \n\n\n\n\nSupport\n\n\nEmail\n\n\nContact us via email at \nsupport@authentiq.io\n.\n\n\nChat\n\n\nJoin the Authentiq team on IRC at \n#authentiq@freenode.net\n.\n\n\nIssues\n\n\nDiscuss bugs, issues and feature requests on our \nGitHub project page\n.", 
            "title": "Overview"
        }, 
        {
            "location": "/#introduction", 
            "text": "Hey, if you re reading this, then you are probably curious how to get started with implementing  Authentiq  on your website.   Fortunately, as we run Authentiq Connect as a service, there is no need to install or run anything locally. Simply include our JavaScript snippet on your page or point your favourite OAuth 2.0 client library at our hosted instance. Dive right in by heading over to the  Getting started  page.  Of course if you prefer to  install the Authentiq Connect daemon locally , then we will have pre-built packages for Debian 7.0, 8.0 and Ubuntu 15.04 soon. You will also be able to install the Authentiq Connect Provider from PyPI or build it from  source .   Please see our licensing options before installing Authentiq Connect locally to make sure it matches your situation.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#why-authentiq", 
            "text": "Why should I do this and what s so cool about the Authentiq technology again?   Authentiq provides super secure multi-factor authentication.  Authentiq provides you with fresh contact details every time a user signs in.  Authentiq lets your end-users control their identity from their phone.  Authentiq aims to avoid being a single point of failure for your product.  Authentiq aims to avoid being another point of trust for your users.  Authentiq aims to be reasonably priced, or free.", 
            "title": "Why Authentiq?"
        }, 
        {
            "location": "/#concepts", 
            "text": "This section attempts to explain general concepts relating to Authentiq Connect.", 
            "title": "Concepts"
        }, 
        {
            "location": "/#scopes", 
            "text": "Authentiq Connect leverages OAuth 2.0  scopes  to specify what sections of a user s profile are being requested. We mimic the  scopes from OIDC  as much as possible, and prefix additional scopes with a  aq: .  Identity claims  Using scopes, a client application can request the following user details from a user.       Label  Description  Claims  Can be marked required?  Can be signed?      email  A user s (verified) email address.  email ,  email_verified  Yes  Yes    phone  A user s (verified) phone number.  phone_number ,  phone_number_verified  Yes  Yes    address  A user s home address.  address  Yes  No    aq:name  A user s full name.  name ,  given_name ,  family_name ,  middle_name ,  nickname  Yes  No    aq:location  A user s current location.  aq:location  Yes  No     Following OIDC, requested scopes are optional by default, meaning that a user will be able to opt out of a requested scope on the Authentiq ID user consent screen. In this case it is up to the client application to decide how to deal with the missing information. Alternatively, Authentiq allows a developer to mark certain scopes as required and/or requiring a signature from a trusted issuer.   Required claims  Identity scopes can be marked as being  required  by appending  ~r , for instance  email~r  or  aq:name~r . Doing so will prevent a user from opting out of the section when signing in from the Authentiq ID app. We recommend to use this flag with care and instead let your users remain in control of the information they share with you.    Signed claims  Scopes can also be marked to  require a signature  from an externally trusted party. In fact, Authentiq is acting as a signature provider for the email and phone scopes, handling the confirmation of email addresses and phone number using a one-time verification code sent by email or text message.  Functional scopes  Authentiq Connect also uses scopes to indicate functional preferences.      Label  Description      aq:push  Whether or not to offer  One click sign-in  to the user.", 
            "title": "Scopes"
        }, 
        {
            "location": "/#errors", 
            "text": "When something goes wrong, Authentiq Connect tries to direct back to the client application as stipulated by OAuth 2.0, so that the error can be handled in the domain and using the UX of the client application.  The native SDK handles all errors for you, however here is a list of things that may go wrong for reference.     Error  Origin  Grants  Description      invalid_XYZ  OAuth 2.0  Authorization code     consent_required  OIDC  Authorization code  The user did not The user did not The user did not The user did not", 
            "title": "Errors"
        }, 
        {
            "location": "/#terminology", 
            "text": "Let s get over some terminology used in this documentation.   Authentiq Connect  The authentication protocol defined by Authentiq.  Authentiq Connect Provider  The actual daemon that serves the Authentiq Connect protocol, acting as a bridge between website and app. The provider is packaged as  authentiqd  in the context of SysV-style init scripts.  Authentiq Connect SDK  The combination of the hosted (or installable) Authentiq Connect Provider and client side JavaScript snippet.  Client or Relying Party  The client website or application that end-users authenticate to. Both Client and Relying Party are used interchangeably in the OpenID Connect specifications.  Certificate Authority List  A public list of signature authorities that allows a Relying Party to verify that a certain identity claim was signed by an active trusted party.  Certificate Revocation List  A public list of unique end-user and (hashed) device identifiers that can be used by a Relying Party to verify that a user is still active and their device hasn t been revoked.", 
            "title": "Terminology"
        }, 
        {
            "location": "/#support", 
            "text": "", 
            "title": "Support"
        }, 
        {
            "location": "/#email", 
            "text": "Contact us via email at  support@authentiq.io .", 
            "title": "Email"
        }, 
        {
            "location": "/#chat", 
            "text": "Join the Authentiq team on IRC at  #authentiq@freenode.net .", 
            "title": "Chat"
        }, 
        {
            "location": "/#issues", 
            "text": "Discuss bugs, issues and feature requests on our  GitHub project page .", 
            "title": "Issues"
        }, 
        {
            "location": "/gettingstarted/", 
            "text": "Introduction\n\n\nThis page describes how to allow your users to sign in with Authentiq ID on your website in minutes.\n\n\nAuthentiq Connect is compatible with both \nOAuth 2.0\n and \nOpenID Connect 1.0 (OIDC)\n, and as such it should feel familiar to anyone having implemented OAuth 2.0 authentication before. In case your application already accepts users from other OAuth 2.0 identity providers (such as Google, Facebook, \n), it should be trivial to enable Authentiq ID as another source of verified users using your existing OAuth 2.0 client implementation.\n\n\nAlternatively, our \nnative Authentiq Connect SDK\n allows you to implement a rich authentication experience in minutes. We recommend this option if you are looking to enhance your registration and sign-in flows, or want to add strong passwordless two-factor authentication to your website.\n\n\nThere are a few important differences to consider when evaluating integration options.\n\n\nOur native Authentiq Connect SDK is easy to use and leverages features of OpenID Connect to obtain a rich authentication experience. But our protocol also works with many of the great third-party OAuth 2.0 client libraries out there already. Deciding what works best for you depends heavily on your situation. In practice, generic OAuth 2.0 libraries tend to work well, but will be less optimized in terms of performance and user experience.\n\n\n\n\nOpenID Connect is an extention to OAuth 2.0 that standardizes user authentication and forms the basis of Authentiq Connect. \n\n\n\n\nIntegration comparison\n\n\nThe following table highlights key differences between the protocol variants.\n\n\n\n\n\n\n\n\nFeature\n\n\nAuthentiq Connect\n\n\nOpenID Connect\n\n\nOAuth 2.0\n\n\n\n\n\n\n\n\n\n\nAuthorization code grant\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nImplicit grant\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nID Token\n support\n\n\nYes\n\n\nYes\n\n\nNo\n\n\n\n\n\n\nRich authentication UX\n\n\nStandard\n\n\nWith some effort\n\n\nLess\n\n\n\n\n\n\nNeed to fetch user information with separate HTTP request\n\n\nNo\n\n\nNo\n\n\nYes\n\n\n\n\n\n\nEnd-to-end verification of user information\n\n\nYes\n\n\nNo\n\n\nNo\n\n\n\n\n\n\nEnd-to-end encryption of user information\n\n\nSoon\n\n\nNo\n\n\nNo\n\n\n\n\n\n\nAuthentiq Connect Provider needs to be trusted by client\n\n\nNo\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nAuthentiq Connect Provider needs to persist user information\n\n\nNo\n\n\nDepends\n\n\nYes\n\n\n\n\n\n\n\n\nObtaining a Client ID\n\n\nWhether or not your integration is going to be native or third-party, you will need to \nregister your application\n with an Authentiq Connect Provider and obtain a unique client identifier. Use the \nclient_id\n in your preferred OAuth 2.0 client library, or when customizing your native Authentiq Connect snippet below. \n\n\nNative SDK\n\n\nIn terms of end-user experience, the smoothest integration option is to simply include our Authentiq Connect snippet on your page. Use the snippet configurator to easily generate cusomtized snippet code for your situation, or copy paste and adjust the example snippet below.\n\n\nConfigurator\n\n\nCreate your own Authentiq button with the Button Configurator.\n\n\nExample\n\n\n    \nscript src=\n//cdn.authentiq.io/authentiq.io/1.0/authentiq.js\n/script\n\n    \nbutton class=\nauthentiq-button\n\n            data-client-id=\n62a90b31-db29-4510-adf4-3d4d7d932d14\n\n            data-provider-uri=\nhttps://connect.authentiq.io/authorize\n\n            data-scopes=\nemail~rs aq:name aq:push\n\n      Sign in with Authentiq ID\n    \n/button\n\n\n\n\nOptions\n\n\nThe following \ndata-*\n options are available.\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\nDefault\n\n\n\n\n\n\n\n\n\n\nclient_id\n\n\nYour registered application ID.\n\n\nNone, obtain a unique ID from the \nClient Console\n.\n\n\n\n\n\n\nprovider_uri\n\n\nProvider Authorization URL.\n\n\nhttps://connect.authentiq.io/authorize\n\n\n\n\n\n\nresponse_type\n\n\nOIDC response type. Valid options are \ncode\n, \ncode id_token\n, \nid_token\n.\n\n\nid_token\n\n\n\n\n\n\nresponse_mode\n\n\nOIDC response mode. Valid options are \nquery\n, \nfragment\n.\n\n\nDepends on response type.\n\n\n\n\n\n\nredirect_uri\n\n\nOAuth 2.0 redirect URL.\n\n\nThe current page, from \nwindow.href.location\n.\n\n\n\n\n\n\nscope\n\n\nProfile scopes to request from user, as a space-separated list. Valid scopes are \nemail\n, \nphone\n, \naq:name\n, \naq:address\n, \naq:location\n and \naq:push\n. Append \n~r\n to indicate that a scope is required and/or \n~s\n to indicate the scope should have a valid signature from a trusted Authentiq Issuer.\n\n\nThe default scopes registered for the client application.\n\n\n\n\n\n\ndisplay\n\n\nAuthorization display mode. Valid choices are \npage\n, \npopup\n or \nmodal\n.\n\n\npage\n\n\n\n\n\n\nprompt\n\n\nPreferred prompt method in Authentiq ID. Valid choices are \nlogin\n, \nconsent\n. Providing \nconsent\n overrides \nOne click sign-in\n and prompts user for (re-)consent.\n\n\nlogin\n\n\n\n\n\n\nui_locales\n\n\nPreferred laguage to display the authorization page in, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. Currently only \nen\n is supported.\n\n\nen\n\n\n\n\n\n\nstate\n\n\nClient application state.\n\n\n32 bytes from \ncrypto.getRandomValues()\n\n\n\n\n\n\nclient_response_uri\n\n\nURL to POST the received authorization response to for server side validation or processing. Method should return 200 or 400. This parameter is only used when \nresponse_mode=fragment\n, since otherwise .\n\n\nNone\n\n\n\n\n\n\n\n\nServer side processing\n\n\nIf the response mode is set to \nfragment\n (recommended), then \nclient_response_uri\n can be used to still proxy the authorization response to your backend servers, as if you had specified \nquery\n response mode. The backend server may do one or more of the following tasks:  \n\n\n\n\nValidate the ID Token, if present, using cryptographic functions available on the server and return a 400 response in case of a validation error.\n\n\nConsume the authorization code, if present, and exchange it for an access and/or refresh token at the Authentiq Connect token endpoint.\n\n\n\n\nThe endpoint should return one of the following status codes. \n\n\n\n\n\n\n\n\nHTTP status code\n\n\nAction\n\n\n\n\n\n\n\n\n\n\n200\n\n\nToken validated; the success callback will be called.\n\n\n\n\n\n\n400\n\n\nToken error; a message will be displayed and the error callback invoked.\n\n\n\n\n\n\n\n\nThird-party integrations\n\n\n\n\n\n\n\n\nTypical option\n\n\nWhat to fill in\n\n\n\n\n\n\n\n\n\n\nclient_id\n\n\nThe client_id you obtained above.\n\n\n\n\n\n\nscope\n\n\nSpace delimited list of \nAuthentiq Connect scopes\n.\n\n\n\n\n\n\nredirect_uri\n\n\nThe URL in \nyour\n application that the Provider should redirect to after authenticating a user.\n\n\n\n\n\n\nauthorize_uri\n\n\nhttps://connect.authentiq.io/authorize\n\n\n\n\n\n\ntoken_uri\n\n\nhttps://connect.authentiq.io/token\n\n\n\n\n\n\nuserinfo_uri\n\n\nhttps://connect.authentiq.io/userinfo\n\n\n\n\n\n\n\n\nClient-side frameworks\n\n\nA list of client libraries using OAuth\ns \nimplicit\n grant type. Please add relevant solutions to this list if they are missing.\n\n\nHello.js\n\n\nThere is a \nfork of HelloJS\n that includes an \nAuthentiq Connect plugin\n. HelloJS abstracts away the implementation differences between a large number of standard OAuth 2.0 identity providers. We\nll aim to get Authentiq Connect included as a supported provider soon.\n\n\nAngular JS\n\n\nAt least two OAuth 2.0 modules exist for AngularJS, both of which have been tested to work with Authentiq Connect.\n\n\n\n\nOAuth-ng\n \n\n\nAngular-OAuth\n\n\n\n\nServer-side frameworks\n\n\nA list of libraries to be used with server applications, supporting (at least) OAuth\ns \nauthorization_code\n grant type. Please add relevant solutions to this list if they are missing.\n\n\nFlask\n\n\nThere are several authentication extensions for Flask\n [TBD]\n\n\nOther integrations\n\n\nAs support for OpenID Connect increases, we expect to see more and more sites that will allow administrators to configure external OIDC identity provider for user authentication, vastly improving the ecosystem for Authentiq ID integrations as well. We already see companies like Amazon and SalesForce making this possible.   \n\n\nAmazon AWS\n\n\nAmazon allows an administrator to configure an external OpenID Connect identity provider as a source for their \nAWS\n console. We\nre planning to supporting this integration at a later stage so that teams will be able to sign in to AWS using their Authentiq ID. \n\n\nAmazon Cognito\n\n\nAmazon allows mobile app developers to configure \nCognito\n with external OpenID Connect identity providers, enabling an app to authenticate users from social networks and a variety of sources. We\nre planning to supporting this integration at a later stage so that mobile app developers will be able to register and authenticate users by their Authentiq ID. \n\n\nSalesForce\n\n\nSalesForce\n allows an administrator configure up an external OpenID Connect identity provider as a source for company employees. We\nre planning to supporting this integration at a later stage so that companies will be able to let their employees sign into SalesForce using their Authentiq ID.", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#introduction", 
            "text": "This page describes how to allow your users to sign in with Authentiq ID on your website in minutes.  Authentiq Connect is compatible with both  OAuth 2.0  and  OpenID Connect 1.0 (OIDC) , and as such it should feel familiar to anyone having implemented OAuth 2.0 authentication before. In case your application already accepts users from other OAuth 2.0 identity providers (such as Google, Facebook,  ), it should be trivial to enable Authentiq ID as another source of verified users using your existing OAuth 2.0 client implementation.  Alternatively, our  native Authentiq Connect SDK  allows you to implement a rich authentication experience in minutes. We recommend this option if you are looking to enhance your registration and sign-in flows, or want to add strong passwordless two-factor authentication to your website.  There are a few important differences to consider when evaluating integration options.  Our native Authentiq Connect SDK is easy to use and leverages features of OpenID Connect to obtain a rich authentication experience. But our protocol also works with many of the great third-party OAuth 2.0 client libraries out there already. Deciding what works best for you depends heavily on your situation. In practice, generic OAuth 2.0 libraries tend to work well, but will be less optimized in terms of performance and user experience.   OpenID Connect is an extention to OAuth 2.0 that standardizes user authentication and forms the basis of Authentiq Connect.", 
            "title": "Introduction"
        }, 
        {
            "location": "/gettingstarted/#integration-comparison", 
            "text": "The following table highlights key differences between the protocol variants.     Feature  Authentiq Connect  OpenID Connect  OAuth 2.0      Authorization code grant  Yes  Yes  Yes    Implicit grant  Yes  Yes  Yes    ID Token  support  Yes  Yes  No    Rich authentication UX  Standard  With some effort  Less    Need to fetch user information with separate HTTP request  No  No  Yes    End-to-end verification of user information  Yes  No  No    End-to-end encryption of user information  Soon  No  No    Authentiq Connect Provider needs to be trusted by client  No  Yes  Yes    Authentiq Connect Provider needs to persist user information  No  Depends  Yes", 
            "title": "Integration comparison"
        }, 
        {
            "location": "/gettingstarted/#obtaining-a-client-id", 
            "text": "Whether or not your integration is going to be native or third-party, you will need to  register your application  with an Authentiq Connect Provider and obtain a unique client identifier. Use the  client_id  in your preferred OAuth 2.0 client library, or when customizing your native Authentiq Connect snippet below.", 
            "title": "Obtaining a Client ID"
        }, 
        {
            "location": "/gettingstarted/#native-sdk", 
            "text": "In terms of end-user experience, the smoothest integration option is to simply include our Authentiq Connect snippet on your page. Use the snippet configurator to easily generate cusomtized snippet code for your situation, or copy paste and adjust the example snippet below.", 
            "title": "Native SDK"
        }, 
        {
            "location": "/gettingstarted/#configurator", 
            "text": "Create your own Authentiq button with the Button Configurator.", 
            "title": "Configurator"
        }, 
        {
            "location": "/gettingstarted/#example", 
            "text": "script src= //cdn.authentiq.io/authentiq.io/1.0/authentiq.js /script \n     button class= authentiq-button \n            data-client-id= 62a90b31-db29-4510-adf4-3d4d7d932d14 \n            data-provider-uri= https://connect.authentiq.io/authorize \n            data-scopes= email~rs aq:name aq:push \n      Sign in with Authentiq ID\n     /button", 
            "title": "Example"
        }, 
        {
            "location": "/gettingstarted/#options", 
            "text": "The following  data-*  options are available.     Name  Description  Default      client_id  Your registered application ID.  None, obtain a unique ID from the  Client Console .    provider_uri  Provider Authorization URL.  https://connect.authentiq.io/authorize    response_type  OIDC response type. Valid options are  code ,  code id_token ,  id_token .  id_token    response_mode  OIDC response mode. Valid options are  query ,  fragment .  Depends on response type.    redirect_uri  OAuth 2.0 redirect URL.  The current page, from  window.href.location .    scope  Profile scopes to request from user, as a space-separated list. Valid scopes are  email ,  phone ,  aq:name ,  aq:address ,  aq:location  and  aq:push . Append  ~r  to indicate that a scope is required and/or  ~s  to indicate the scope should have a valid signature from a trusted Authentiq Issuer.  The default scopes registered for the client application.    display  Authorization display mode. Valid choices are  page ,  popup  or  modal .  page    prompt  Preferred prompt method in Authentiq ID. Valid choices are  login ,  consent . Providing  consent  overrides  One click sign-in  and prompts user for (re-)consent.  login    ui_locales  Preferred laguage to display the authorization page in, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. Currently only  en  is supported.  en    state  Client application state.  32 bytes from  crypto.getRandomValues()    client_response_uri  URL to POST the received authorization response to for server side validation or processing. Method should return 200 or 400. This parameter is only used when  response_mode=fragment , since otherwise .  None     Server side processing  If the response mode is set to  fragment  (recommended), then  client_response_uri  can be used to still proxy the authorization response to your backend servers, as if you had specified  query  response mode. The backend server may do one or more of the following tasks:     Validate the ID Token, if present, using cryptographic functions available on the server and return a 400 response in case of a validation error.  Consume the authorization code, if present, and exchange it for an access and/or refresh token at the Authentiq Connect token endpoint.   The endpoint should return one of the following status codes.      HTTP status code  Action      200  Token validated; the success callback will be called.    400  Token error; a message will be displayed and the error callback invoked.", 
            "title": "Options"
        }, 
        {
            "location": "/gettingstarted/#third-party-integrations", 
            "text": "Typical option  What to fill in      client_id  The client_id you obtained above.    scope  Space delimited list of  Authentiq Connect scopes .    redirect_uri  The URL in  your  application that the Provider should redirect to after authenticating a user.    authorize_uri  https://connect.authentiq.io/authorize    token_uri  https://connect.authentiq.io/token    userinfo_uri  https://connect.authentiq.io/userinfo", 
            "title": "Third-party integrations"
        }, 
        {
            "location": "/gettingstarted/#client-side-frameworks", 
            "text": "A list of client libraries using OAuth s  implicit  grant type. Please add relevant solutions to this list if they are missing.  Hello.js  There is a  fork of HelloJS  that includes an  Authentiq Connect plugin . HelloJS abstracts away the implementation differences between a large number of standard OAuth 2.0 identity providers. We ll aim to get Authentiq Connect included as a supported provider soon.  Angular JS  At least two OAuth 2.0 modules exist for AngularJS, both of which have been tested to work with Authentiq Connect.   OAuth-ng    Angular-OAuth", 
            "title": "Client-side frameworks"
        }, 
        {
            "location": "/gettingstarted/#server-side-frameworks", 
            "text": "A list of libraries to be used with server applications, supporting (at least) OAuth s  authorization_code  grant type. Please add relevant solutions to this list if they are missing.  Flask  There are several authentication extensions for Flask  [TBD]", 
            "title": "Server-side frameworks"
        }, 
        {
            "location": "/gettingstarted/#other-integrations", 
            "text": "As support for OpenID Connect increases, we expect to see more and more sites that will allow administrators to configure external OIDC identity provider for user authentication, vastly improving the ecosystem for Authentiq ID integrations as well. We already see companies like Amazon and SalesForce making this possible.", 
            "title": "Other integrations"
        }, 
        {
            "location": "/gettingstarted/#amazon-aws", 
            "text": "Amazon allows an administrator to configure an external OpenID Connect identity provider as a source for their  AWS  console. We re planning to supporting this integration at a later stage so that teams will be able to sign in to AWS using their Authentiq ID.", 
            "title": "Amazon AWS"
        }, 
        {
            "location": "/gettingstarted/#amazon-cognito", 
            "text": "Amazon allows mobile app developers to configure  Cognito  with external OpenID Connect identity providers, enabling an app to authenticate users from social networks and a variety of sources. We re planning to supporting this integration at a later stage so that mobile app developers will be able to register and authenticate users by their Authentiq ID.", 
            "title": "Amazon Cognito"
        }, 
        {
            "location": "/gettingstarted/#salesforce", 
            "text": "SalesForce  allows an administrator configure up an external OpenID Connect identity provider as a source for company employees. We re planning to supporting this integration at a later stage so that companies will be able to let their employees sign into SalesForce using their Authentiq ID.", 
            "title": "SalesForce"
        }, 
        {
            "location": "/installation/", 
            "text": "Introduction\n\n\nThere is nothing to install when running Authentiq as a Service. Just register your client application at our hosted authentication service and head over to \nGetting started\n. This page describes how to install Authentiq Connect locally on your own system, in case you prefer that.\n\n\n\n\nPlease see our licensing options if you want to follow this path to make sure it matches with your situation.\n\n\n\n\nInstallation\n\n\nFrom pre-built packages\n\n\nPre-built packages are available at the moment for Debian 7.0, 8.0 and Ubuntu 15.04.\n\n\nDebian \n Ubuntu\n\n\nAdd our repository to your APT sources, as root:\n\n\napt-add-repository\napt-get update\napt-get install authentiq-connect\n\n\n\n\nEdit the configuration file, see \nbelow\n for details about the available configuration options:\n\n\nvim /etc/authentiq/authentiqd.conf\n\n\n\n\n(Re)start the service:\n\n\n/etc/init.d/authentiqd restart\n\n\n\n\nFrom PyPI\n\n\nYou can also install \nauthentiqd\n using PyPi. We recommend you use a virtual Python environment in this case to not clutter up your system with dependencies.\n\n\npip install authentiq-connect\n\n\n\n\nEdit the configuration file, see \nbelow\n for details about the available configuration options:\n\n\nvim ./etc/authentiqd.conf\n\n\n\n\nBe sure to check out available command line options for the daemon:\n\n\n./bin/authentiq-provider --help\n\nusage: authentiq-provider [-h] [-v] [-D] [--log LOG] [--bind BIND] [--port PORT]\n                       [--insecure] [--schema] [--gunicorn]\n                       [--workers WORKERS] [--name NAME]\n                       [--disable-websockets]\n\nAuthentiq Connect Provider\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -v, --verbose         increase verbosity (default: 0)\n  -D, --debug           enable Flask debugging (default: False)\n  --log LOG             write logs to (rotated) file (default: None)\n  --bind BIND           ip to bind to (default: localhost)\n  --port PORT           port to bind to (default: 5000)\n  --insecure            disable JWT signature verification (default: False)\n  --schema              create schema for database (default: False)\n  --gunicorn            run under gunicorn (default: False)\n  --workers WORKERS     start this many worker processes (gunicorn only)\n                        (default: 1)\n  --name NAME           process name to use (gunicorn only) (default: aq-\n                        provider)\n  --disable-websockets  run server without WebSocket support (default: False)\n\n\n\n\nThen start the daemon:\n\n\n./bin/authentiq-provider\n\n\n\n\nFrom source\n\n\nFork and/or clone the Github repository,\n\n\ngit clone github...\n\n\n\n\nand run:\n\n\npython setup.py\n\n\n\n\nor install from source using PyPI:\n\n\npip install -e github...\n\n\n\n\nConfiguration\n\n\n\n\nDescribe configuration file here. \n\n\n\n\nDeployment\n\n\nThe daemon binds to localhost by default on purpose, you should really deploy \nauthentiqd\n behind a caching webserver. We describe how to configure Nginx here, but the configuration can easily be translated to other servers.\n\n\nNginx\n\n\n\n\nDescribe nginx configuration details with well-commented snippet..", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#introduction", 
            "text": "There is nothing to install when running Authentiq as a Service. Just register your client application at our hosted authentication service and head over to  Getting started . This page describes how to install Authentiq Connect locally on your own system, in case you prefer that.   Please see our licensing options if you want to follow this path to make sure it matches with your situation.", 
            "title": "Introduction"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#from-pre-built-packages", 
            "text": "Pre-built packages are available at the moment for Debian 7.0, 8.0 and Ubuntu 15.04.  Debian   Ubuntu  Add our repository to your APT sources, as root:  apt-add-repository\napt-get update\napt-get install authentiq-connect  Edit the configuration file, see  below  for details about the available configuration options:  vim /etc/authentiq/authentiqd.conf  (Re)start the service:  /etc/init.d/authentiqd restart", 
            "title": "From pre-built packages"
        }, 
        {
            "location": "/installation/#from-pypi", 
            "text": "You can also install  authentiqd  using PyPi. We recommend you use a virtual Python environment in this case to not clutter up your system with dependencies.  pip install authentiq-connect  Edit the configuration file, see  below  for details about the available configuration options:  vim ./etc/authentiqd.conf  Be sure to check out available command line options for the daemon:  ./bin/authentiq-provider --help\n\nusage: authentiq-provider [-h] [-v] [-D] [--log LOG] [--bind BIND] [--port PORT]\n                       [--insecure] [--schema] [--gunicorn]\n                       [--workers WORKERS] [--name NAME]\n                       [--disable-websockets]\n\nAuthentiq Connect Provider\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -v, --verbose         increase verbosity (default: 0)\n  -D, --debug           enable Flask debugging (default: False)\n  --log LOG             write logs to (rotated) file (default: None)\n  --bind BIND           ip to bind to (default: localhost)\n  --port PORT           port to bind to (default: 5000)\n  --insecure            disable JWT signature verification (default: False)\n  --schema              create schema for database (default: False)\n  --gunicorn            run under gunicorn (default: False)\n  --workers WORKERS     start this many worker processes (gunicorn only)\n                        (default: 1)\n  --name NAME           process name to use (gunicorn only) (default: aq-\n                        provider)\n  --disable-websockets  run server without WebSocket support (default: False)  Then start the daemon:  ./bin/authentiq-provider", 
            "title": "From PyPI"
        }, 
        {
            "location": "/installation/#from-source", 
            "text": "Fork and/or clone the Github repository,  git clone github...  and run:  python setup.py  or install from source using PyPI:  pip install -e github...", 
            "title": "From source"
        }, 
        {
            "location": "/installation/#configuration", 
            "text": "Describe configuration file here.", 
            "title": "Configuration"
        }, 
        {
            "location": "/installation/#deployment", 
            "text": "The daemon binds to localhost by default on purpose, you should really deploy  authentiqd  behind a caching webserver. We describe how to configure Nginx here, but the configuration can easily be translated to other servers.", 
            "title": "Deployment"
        }, 
        {
            "location": "/installation/#nginx", 
            "text": "Describe nginx configuration details with well-commented snippet..", 
            "title": "Nginx"
        }, 
        {
            "location": "/api-provider/", 
            "text": "Authentication\n\n\n/authorize\n\n\n/token\n\n\n/userinfo\n\n\nClient Management\n\n\n/client\n\n\n/client/1234\n\n\nSession Management\n\n\n/authorize/logout\n\n\n/authorize/iframe\n\n\nSessions\n\n\n/session\n\n\n/client/1234/session\n\n\n\n\n\n\n  \n\n    \n\n      \n\n        \nswagger\n\n        \n\n          \n\n          \n\n          \nExplore\n\n        \n\n      \n\n    \n\n\n    \n\n    \n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  $(function () {\n    window.swaggerUi = new SwaggerUi({\n      url: \"provider.yaml\",\n      dom_id: \"swagger-ui-container\",\n      supportedSubmitMethods: ['get', 'post', 'put', 'delete', 'patch'],\n      onComplete: function(swaggerApi, swaggerUi){\n        // if(typeof initOAuth == \"function\") {\n        //   initOAuth({\n        //     clientId: \"your-client-id\",\n        //     realm: \"your-realms\",\n        //     appName: \"your-app-name\"\n        //   });\n        // }\n\n        $('pre code').each(function(i, e) {\n          hljs.highlightBlock(e)\n        });\n\n        addApiKeyAuthorization();\n      },\n      onFailure: function(data) {\n        log(\"Unable to Load SwaggerUI\");\n      },\n      docExpansion: \"none\",\n      apisSorter: \"alpha\",\n      showRequestHeaders: false\n    });\n\n    function addApiKeyAuthorization(){\n      var key;\n      if ('authentiq' in window) {\n        key = window.authentiq.Token.getAuthorizationHeader();\n      }\n      // var key = encodeURIComponent($('#input_apiKey')[0].value);\n      if(key && key.trim() != \"\") {\n          var token = new SwaggerClient.ApiKeyAuthorization(\"Authorization\", key, \"header\");\n          window.swaggerUi.api.clientAuthorizations.add(\"access_token\", token);\n          log(\"added key \" + key);\n      }\n    }\n\n    // $('#input_apiKey').change(addApiKeyAuthorization);\n\n    // if you have an apiKey you would like to pre-populate on the page for demonstration purposes...\n    /*\n      var apiKey = \"myApiKeyXXXX123456789\";\n      $('#input_apiKey').val(apiKey);\n    */\n\n    window.swaggerUi.load();\n\n    function log() {\n      if ('console' in window) {\n        console.log.apply(console, arguments);\n      }\n    }\n  });", 
            "title": "Connect"
        }, 
        {
            "location": "/api-provider/#authentication", 
            "text": "", 
            "title": "Authentication"
        }, 
        {
            "location": "/api-provider/#authorize", 
            "text": "", 
            "title": "/authorize"
        }, 
        {
            "location": "/api-provider/#token", 
            "text": "", 
            "title": "/token"
        }, 
        {
            "location": "/api-provider/#userinfo", 
            "text": "", 
            "title": "/userinfo"
        }, 
        {
            "location": "/api-provider/#client-management", 
            "text": "", 
            "title": "Client Management"
        }, 
        {
            "location": "/api-provider/#client", 
            "text": "", 
            "title": "/client"
        }, 
        {
            "location": "/api-provider/#client1234", 
            "text": "", 
            "title": "/client/1234"
        }, 
        {
            "location": "/api-provider/#session-management", 
            "text": "", 
            "title": "Session Management"
        }, 
        {
            "location": "/api-provider/#authorizelogout", 
            "text": "", 
            "title": "/authorize/logout"
        }, 
        {
            "location": "/api-provider/#authorizeiframe", 
            "text": "", 
            "title": "/authorize/iframe"
        }, 
        {
            "location": "/api-provider/#sessions", 
            "text": "", 
            "title": "Sessions"
        }, 
        {
            "location": "/api-provider/#session", 
            "text": "", 
            "title": "/session"
        }, 
        {
            "location": "/api-provider/#client1234session", 
            "text": "swagger \n         \n           \n           \n           Explore \n         \n       \n     \n\n     \n     \n                   \n  $(function () {\n    window.swaggerUi = new SwaggerUi({\n      url: \"provider.yaml\",\n      dom_id: \"swagger-ui-container\",\n      supportedSubmitMethods: ['get', 'post', 'put', 'delete', 'patch'],\n      onComplete: function(swaggerApi, swaggerUi){\n        // if(typeof initOAuth == \"function\") {\n        //   initOAuth({\n        //     clientId: \"your-client-id\",\n        //     realm: \"your-realms\",\n        //     appName: \"your-app-name\"\n        //   });\n        // }\n\n        $('pre code').each(function(i, e) {\n          hljs.highlightBlock(e)\n        });\n\n        addApiKeyAuthorization();\n      },\n      onFailure: function(data) {\n        log(\"Unable to Load SwaggerUI\");\n      },\n      docExpansion: \"none\",\n      apisSorter: \"alpha\",\n      showRequestHeaders: false\n    });\n\n    function addApiKeyAuthorization(){\n      var key;\n      if ('authentiq' in window) {\n        key = window.authentiq.Token.getAuthorizationHeader();\n      }\n      // var key = encodeURIComponent($('#input_apiKey')[0].value);\n      if(key && key.trim() != \"\") {\n          var token = new SwaggerClient.ApiKeyAuthorization(\"Authorization\", key, \"header\");\n          window.swaggerUi.api.clientAuthorizations.add(\"access_token\", token);\n          log(\"added key \" + key);\n      }\n    }\n\n    // $('#input_apiKey').change(addApiKeyAuthorization);\n\n    // if you have an apiKey you would like to pre-populate on the page for demonstration purposes...\n    /*\n      var apiKey = \"myApiKeyXXXX123456789\";\n      $('#input_apiKey').val(apiKey);\n    */\n\n    window.swaggerUi.load();\n\n    function log() {\n      if ('console' in window) {\n        console.log.apply(console, arguments);\n      }\n    }\n  });", 
            "title": "/client/1234/session"
        }, 
        {
            "location": "/api-issuer/", 
            "text": "Example\n\n\n/authorize\n\n\n/token\n\n\n/userinfo\n\n\n\n\n\n\n  \n\n    \n\n    \n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  $(function () {\n    window.swaggerUi = new SwaggerUi({\n      url: \"../swagger/issuer.yaml\",\n      dom_id: \"swagger-ui-container\",\n      supportedSubmitMethods: ['get', 'post', 'put', 'delete', 'patch'],\n      onComplete: function(swaggerApi, swaggerUi){\n        // if(typeof initOAuth == \"function\") {\n        //   initOAuth({\n        //     clientId: \"your-client-id\",\n        //     realm: \"your-realms\",\n        //     appName: \"your-app-name\"\n        //   });\n        // }\n\n        $('pre code').each(function(i, e) {\n          hljs.highlightBlock(e)\n        });\n\n        addApiKeyAuthorization();\n      },\n      onFailure: function(data) {\n        log(\"Unable to Load SwaggerUI\");\n      },\n      docExpansion: \"none\",\n      apisSorter: \"alpha\",\n      showRequestHeaders: false\n    });\n\n    function addApiKeyAuthorization(){\n      var key;\n      if ('authentiq' in window) {\n        key = window.authentiq.Token.getAuthorizationHeader();\n      }\n      // var key = encodeURIComponent($('#input_apiKey')[0].value);\n      if(key && key.trim() != \"\") {\n          var token = new SwaggerClient.ApiKeyAuthorization(\"Authorization\", key, \"header\");\n          window.swaggerUi.api.clientAuthorizations.add(\"access_token\", token);\n          log(\"added key \" + key);\n      }\n    }\n\n    // $('#input_apiKey').change(addApiKeyAuthorization);\n\n    // if you have an apiKey you would like to pre-populate on the page for demonstration purposes...\n    /*\n      var apiKey = \"myApiKeyXXXX123456789\";\n      $('#input_apiKey').val(apiKey);\n    */\n\n    window.swaggerUi.load();\n\n    function log() {\n      if ('console' in window) {\n        console.log.apply(console, arguments);\n      }\n    }\n  });", 
            "title": "Issuer"
        }, 
        {
            "location": "/api-issuer/#example", 
            "text": "", 
            "title": "Example"
        }, 
        {
            "location": "/api-issuer/#authorize", 
            "text": "", 
            "title": "/authorize"
        }, 
        {
            "location": "/api-issuer/#token", 
            "text": "", 
            "title": "/token"
        }, 
        {
            "location": "/api-issuer/#userinfo", 
            "text": "$(function () {\n    window.swaggerUi = new SwaggerUi({\n      url: \"../swagger/issuer.yaml\",\n      dom_id: \"swagger-ui-container\",\n      supportedSubmitMethods: ['get', 'post', 'put', 'delete', 'patch'],\n      onComplete: function(swaggerApi, swaggerUi){\n        // if(typeof initOAuth == \"function\") {\n        //   initOAuth({\n        //     clientId: \"your-client-id\",\n        //     realm: \"your-realms\",\n        //     appName: \"your-app-name\"\n        //   });\n        // }\n\n        $('pre code').each(function(i, e) {\n          hljs.highlightBlock(e)\n        });\n\n        addApiKeyAuthorization();\n      },\n      onFailure: function(data) {\n        log(\"Unable to Load SwaggerUI\");\n      },\n      docExpansion: \"none\",\n      apisSorter: \"alpha\",\n      showRequestHeaders: false\n    });\n\n    function addApiKeyAuthorization(){\n      var key;\n      if ('authentiq' in window) {\n        key = window.authentiq.Token.getAuthorizationHeader();\n      }\n      // var key = encodeURIComponent($('#input_apiKey')[0].value);\n      if(key && key.trim() != \"\") {\n          var token = new SwaggerClient.ApiKeyAuthorization(\"Authorization\", key, \"header\");\n          window.swaggerUi.api.clientAuthorizations.add(\"access_token\", token);\n          log(\"added key \" + key);\n      }\n    }\n\n    // $('#input_apiKey').change(addApiKeyAuthorization);\n\n    // if you have an apiKey you would like to pre-populate on the page for demonstration purposes...\n    /*\n      var apiKey = \"myApiKeyXXXX123456789\";\n      $('#input_apiKey').val(apiKey);\n    */\n\n    window.swaggerUi.load();\n\n    function log() {\n      if ('console' in window) {\n        console.log.apply(console, arguments);\n      }\n    }\n  });", 
            "title": "/userinfo"
        }, 
        {
            "location": "/clients/", 
            "text": "Client management\n\n\nTo allow people to sign in using Authentiq ID, you need to register your application as a client with the Provider.\n\n\nVisit the \nProvider Console\n to manage your \nclients\n.", 
            "title": "Your clients"
        }, 
        {
            "location": "/clients/#client-management", 
            "text": "To allow people to sign in using Authentiq ID, you need to register your application as a client with the Provider.  Visit the  Provider Console  to manage your  clients .", 
            "title": "Client management"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently Asked Questions\n\n\nWhat is Authentiq ID?\n\n\nWhen you download our app and create a profile, that is your very own Authentiq ID. Use it to sign into websites, or share your details in other ways.\n\n\nWhat is Authentiq Connect?\n\n\nAuthentiq Connect is the SDK you can use to let your users sign in to your stuff. On the server side it implements both OAuth 2.0 and OpenID Connect protocols, giving developers the most flexible integration options. The client JavaScript component exploits these  \n\n\nWhat is OpenID Connect?\n\n\nOpenID Connect 1.0 is a set of extensions to OAuth 2.0, focusing on authentication as opposed to authorization. Many global players are backing OpenID Connect to authenticate users.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#frequently-asked-questions", 
            "text": "What is Authentiq ID?  When you download our app and create a profile, that is your very own Authentiq ID. Use it to sign into websites, or share your details in other ways.  What is Authentiq Connect?  Authentiq Connect is the SDK you can use to let your users sign in to your stuff. On the server side it implements both OAuth 2.0 and OpenID Connect protocols, giving developers the most flexible integration options. The client JavaScript component exploits these    What is OpenID Connect?  OpenID Connect 1.0 is a set of extensions to OAuth 2.0, focusing on authentication as opposed to authorization. Many global players are backing OpenID Connect to authenticate users.", 
            "title": "Frequently Asked Questions"
        }
    ]
}